# Why Versions?

One of the goals of torasu is also to provide a possibility of solid caching-model.

To know when caches become invalid, versions will need to be provided, which invalidate results upon change.

## Why so complicated?

And why not just use a single number to identify whether the graph has updated or not? 

If only a single number would determine the version of all results, means that once single change is done, all cached results will become invalid.
Which might not be necessary if the component changed is only relevant for a fraction of the results. 

So this model tries to provide a version system which allows for only specific results to become invalid which might be effected by the change, while trying to keep version checks reasonably quick (for what we are doing) and with also keeping it relatively simple to implement versioning in the components.

# Version Format

Versions in torasu are numbers (same number-type as element-id's) either single (for local-version and tree-version) and in a chained format of multiple numbers (for combined version), latter can be hashed to be become 1–4 numbers again to be more manageable.

# Local Version

The local version represents the version concerning an element locally regardless of the versions of connected elements.

It will update when internal data will be changed and might change when element-connections are changed, versions are incremented by the element.

The version is a single version-number and can be read and written if the element is changed back to a state where the version is already known (for example when undoing).


# Tree Version

The tree version is a single version-number to be incremented once any element or connection in the tree is updated.

Once this version changes, some combined versions inside the tree might have changed.

# Combined Version

Version generated by renderable, to determine if something about the result could have changed.

## Version Levels

There are different levels of these versions, if a higher level version (e.g.: `global`) has not changed, lower level versions (e.g.: `rendered`) will also not have changed.

- `global`: Version of all possible results 
	- params: none
	- result: version
- `pipeline`: Version of all possible results across each pipeline
	- params: pipeline
	- result: version
- `context`: Version of a specific result, without rendering
	- params: pipeline, context
	- result: version, context-mask
- `rendered`: Version of a specific result, with rendering
	- params: pipeline, context, render-interface
	- result: version, context-mask

Note: A context-mask in the version-result always has to contain the result-mask at any context inside the mask (aka. "result-mask always has to be a subset context-mask of the version of the given result" or "there can not exist two different versions corresponding to the same result")

Examples:
- If a `global` version has not changed, all possible `pipeline`/`context`/`rendered` will still be the same
- If a context/rendered version for pipeline X has changed, the global version and the `pipeline` version for X will also have changed, other pipeline versions and `context`/`rendered` might not have changed though
- If a `pipeline` version for pipeline X has not changed, all `context`/`rendered` in pipeline X will be the same, but `pipeline`/`context`/`rendered` in different pipelines might be different
- If a `rendered` version has changed, that the `context` version for the same pipeline/context will also have changed
- If a `context` version has changed, that the `rendered` version might not have changed, but could

### Providing the next Lowest Level

For renderables that have versions that are not dependent on pipeline/context/render-results, there is an option to define the next level that is actually different from the current one being queried, so a query doesn't need to be executed just to receive the same result. Additionally, this flag can also be used that all lower levels will be the same.

Examples: 
- Query for `global`; next-level is context; Means versions for `pipeline` will be the same
- Query if for `pipeline`; next-level is none; Means versions for `context`, `rendered` inside the same pipeline will be the same

Note: The next-level needs to be correctly set when versions are getting combined.

## Generation of Combined Versions

A combined version of a renderable is generated by combining all combined versions of child-renderables and also add the local version (if the renderable has one present), so that a new version is created that represents all combined versions. 
Important is only, that it stays the same if no version changes and if one of the versions is different the combined version is also different.

### Example Strategy for Combination

Combine each child-renderable's ID with its version and concatonate those additionally with the local version of the current renderable, if it applies.

Example: `(LOCAL-VER) (RND-A ID) (RND-A COMB-VER) (RND-B ID) (RND-B COMB-VER)`

In case the renderable has a variable amount child-renderables, the local version needs to be updated. (Reason: A version might increase its length in the same way another version has decreased and with the right numbers this might result in the same concatenation as before if the local version is not changed).

## Versions and sending renderables via Context

When renderables are sent via render-context and rendered elsewhere, the renderable which is getting sent is still relevant for version. 

To also incorporate this case into the version correctly, the injector needs to combine the version of the renderable for the `global` and `pipeline` passes and the renderable using it needs to combine it into the version for the `context` and `rendered` passes.

- `global`: Injector combines `global` version of renderable to inject into and `global` version of injected renderable
- `pipeline`: Injector combines `pipeline` version of renderable to inject into and `global` version of injected renderable (since we don't know the pipeline it might get called with later)
- `context`: Renderable that uses the injected renderable, incorporates the `context` version of the renderable from the context like other used renderables
- `rendered`: Renderable that uses the injected renderable, incorporates the `rendered` version of the renderable from the context like other used renderables

# Practice to using Versions

Some examples/recommendations for implementation of the described system

## Elements providing Versions

### Local Versions in Elements

Elements will receive `getVersion() -> ver` and `setVersion(ver)` function to set local version. `setVersion` does not have to set the version, it's more just an information that the element has now been configured to a certain known version, the element itself can decide if it wants to accept that version or calculate the version on another way (e.g. hashing). The element itself is responsible for updating its local version when data inside the element is changed.

### Combined Versions in renderables

Renderables will also recieve a `combinedVersion(versionParams) -> versionResult` function to generate a combined version. The parameters and result will be as described for each version-level above.

The parameters will also contain an interface to retrieve versions of used renderables (the `combinedVersion` function should never call the `combinedVersion` function of another element directly, instead it should use the interface to enable version caching).

Another possible parameter exists to disable the hashing of the version-chain for debugging (optional feature).

With this way, simple renderables that don't have any pipeline- or context-dependency versioning will have a simple implementation of `combinedVersion`, which will just involve a call of a helper method that takes the method-params, local-version and renderables to be use in the version. But more complicated renderables with pipeline- and/or context-dependency can still expand on this to improve the quality of versions in those cases.

## Validity-checks in Caches

For caches to make sure that they always hold a valid result they can use a combined-version to ensure that. For optimal longevity the level `rendered` should be used.
Once it is clear a result should be cached the corresponding combined-version(s) are stored.

As soon as the tree version changes, the combined-versions inside the every cache inside the tree need to be checked for validity, this can be done immediately, but can also be done on demand.

For a cache which stores all levels of combined-version a check for a cache can look like this:
- Retrieve `gloabl` version, if it matches cache is ok.
- When `global` mismatches, retrieve `pipeline` version, if it matches cache is ok.
- When `pipeline` mismatches, retrieve `context` version, if it matches cache is ok.
- When `context` mismatches, retrieve `rendered` version, if it matches cache is ok.
- When `rendered` mismatches, cache is no longer good.

Note that here redundant levels can be skipped as described before, to save performance.

Just checking the `rendered` version will give you the same accuracy, but querying the higher levels first has a potential to be quicker – For example: The `global` version exists only once per element, but there might be N different `context`/`rendered` versions because of the context. So when trying to validate all cache entries against `global` first and only querying a `rendered` version for caches which failed the validation against `global` can improve performance compared to re-checking all `rendered` versions present in cache.

## Retrieval of Combined Versions

Versions can be retrieved via a custom render-pipeline, which is automatically routed to the `combinedVersion` function to benefit from most heavy lifting on the implementation-side being done for rendering, like being able to send the request to another device (if necessary) or the caching system (though this might need a custom cache to handle the different version levels efficiently).

# Glossary

Just a small glossary explaining terms relevant in here

- **Element**: Node in the torasu-tree - it can have connections to other node and/or contain certain node-specific versions
- **Renderable**: An Element which can provide ("render") a result (`RenderResult`) which can depend on certain parameters (RenderContext) - can be thought of a function which provides a result based on the provided arguments
- **(Render)Context**: Can be seen as a list of arguments that are provided to a Renderable
- **(Render)ContextMask**: Is a mask which defines a set of RenderContexts - Usually used to define validity of results against other RenderContexts that they were originally generated with
- **(Render)Pipeline**: A pipeline needs to be provided (alongside of the optional `RenderContext`) when rendering results from Renderables to define the "topic" to be rendered. For example there is a pipeline for numbers, audio, video, etc.
- **(Render)Result**: Result of a render-call to a Renderable, it can contain a `RenderContextMask` to describe for what arguments (RenderContext) the result is valid and the same

